<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Method description · OptEnrichedSetCover.jl</title><meta name="title" content="Method description · OptEnrichedSetCover.jl"/><meta property="og:title" content="Method description · OptEnrichedSetCover.jl"/><meta property="twitter:title" content="Method description · OptEnrichedSetCover.jl"/><meta name="description" content="Documentation for OptEnrichedSetCover.jl."/><meta property="og:description" content="Documentation for OptEnrichedSetCover.jl."/><meta property="twitter:description" content="Documentation for OptEnrichedSetCover.jl."/><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="search_index.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img src="assets/logo.png" alt="OptEnrichedSetCover.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="index.html">OptEnrichedSetCover.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="index.html">Introduction</a></li><li class="is-active"><a class="tocitem" href="method.html">Method description</a><ul class="internal"><li><a class="tocitem" href="#Basic-Definitions"><span>Basic Definitions</span></a></li><li><a class="tocitem" href="#cover_quality"><span>Cover quality</span></a></li></ul></li><li><a class="tocitem" href="mosaic.html">Sets collection</a></li><li><a class="tocitem" href="cover_problem.html">Cover problem</a></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="array_pool.html">Array pool</a></li><li><a class="tocitem" href="sparse_mask_matrix.html">Sparse mask matrix</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="method.html">Method description</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="method.html">Method description</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/alyst/OptEnrichedSetCover.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/alyst/OptEnrichedSetCover.jl/blob/master/docs/src/method.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="method"><a class="docs-heading-anchor" href="#method">Method description</a><a id="method-1"></a><a class="docs-heading-anchor-permalink" href="#method" title="Permalink"></a></h1><h2 id="Basic-Definitions"><a class="docs-heading-anchor" href="#Basic-Definitions">Basic Definitions</a><a id="Basic-Definitions-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Definitions" title="Permalink"></a></h2><p>Let</p><ul><li><span>$G = \{ g_1, g_2, \ldots, g_N \}$</span>: the <em>annotated entities</em> (e.g. ENTREZ genes)</li><li><span>$O = \{ o_1, o_2, \ldots, o_M \}$</span>: the entities <em>observed</em> in the experiments (e.g. <em>protein groups</em>)</li><li><span>$\mathrm{obs}: G \mapsto O$</span>: the function that <em>maps</em> annotated entities to the observed ones; <span>$\forall o \in O$</span> <span>$\exists \mathrm{obs}^{-1}(o) \subset G$</span> (an <em>observed</em> entity may refer to several <em>annotated</em> ones)</li><li><span>$\mathcal{A} = \{ A_1, A_2, \ldots, A_{N_T} \}$</span>: the collection of <em>annotation terms</em>, <span>$A_i \subset G$</span></li><li><span>$\mathcal{X} = \{ X_1, X_2, \ldots, X_{M_X} \}$</span>: the collection of <em>experiment hits</em> (e.g. significantly regulated proteins), <span>$X_j \subset O$</span></li><li><span>$C = \{ c_1, c_2, \ldots, c_{N_T} \}$</span>, <span>$0 \leq c_i \leq 1$</span>: weighted <em>cover</em> of the experiment hits, where <span>$c_i$</span> defines the probability to use the annotation term <span>$A_i$</span> for the cover (if <span>$c_i = 0$</span>, the term <span>$A_i$</span> is never used; if <span>$c_i = 1$</span>, it is always in the cover)</li><li><span>$P_{\mathrm{FET}}(A, H, \mathrm{All}) = P(X \geq N_{A\cap H})$</span>, where <span>$X \propto \mathrm{Hypergeomtetric}(N_{A}, N_{H}, N_{\mathrm{All}})$</span> – the <span>$P$</span>-value of the <a href="https://en.wikipedia.org/wiki/Fisher%27s_exact_test">Fisher&#39;s Exact Test</a> that the overlap of the sets <span>$A \subset \mathrm{All}$</span> (e.g. annotation term) and <span>$H \subset \mathrm{All}$</span> (e.g. hits) is significant</li></ul><img alt="Figure: Basic definitions" src="assets/method_defs.svg" width="80%"/><h2 id="cover_quality"><a class="docs-heading-anchor" href="#cover_quality">Cover quality</a><a id="cover_quality-1"></a><a class="docs-heading-anchor-permalink" href="#cover_quality" title="Permalink"></a></h2><p>The method works by defining the <em>cover quality</em> <span>$q(C, \mathcal{X})$</span> of how well the selected terms (<span>$C$</span>) <em>cover</em> the experiment hits (<span>$\mathcal{X}$</span>). Since some aspects of cover quality could not be simultaneously satisfied (e.g. using as few annotation terms as possible vs covering all hits), the score <span>$q$</span> is composed of several components, and multi-objective optimization is employed to find the family of optimal covers.</p><p>More specifically, <span>$q = (q_e, q_r, q_u, q_c)$</span>, where</p><ul><li><span>$q_e$</span>: <em>enrichment</em> score, measures how much the <em>cover terms</em> are enriched within the experiment hits (across all experiments)</li><li><span>$q_r$</span>: <em>redundancy</em> score, penalizes for the presence of redundant terms in the cover</li><li><span>$q_u$</span>: <em>hits cover</em> score, measures how well individual hits are covered by <span>$C$</span></li><li><span>$q_c$</span>: <em>non-hits cover</em> score, penalizes for covering observed entities that are not hits</li></ul><h3 id="cover_quality_enrichment"><a class="docs-heading-anchor" href="#cover_quality_enrichment">Enrichment score</a><a id="cover_quality_enrichment-1"></a><a class="docs-heading-anchor-permalink" href="#cover_quality_enrichment" title="Permalink"></a></h3><p class="math-container">\[q_e(C, \mathcal{X}) = \sum_{i=1}^{N_T} c_i L(A_i, O) E(\mathrm{obs}(A_i), \mathcal{X}),\]</p><p>where <span>$L(A_i, O)$</span> is the <em>relevance</em> of the term <span>$A_i$</span> with respect to the observable elements <span>$O$</span>, and <span>$E(\mathrm{obs}(A_i), \mathcal{X})$</span> is the <em>overall enrichment</em> of <span>$A_i$</span> in the experiment hits <span>$\mathcal{X}$</span>.</p><p><em>Relevance</em> component allows to prioritize the annotation terms that are better represented among the observed entities, but otherwise have the same enrichment as less represented ones:</p><p class="math-container">\[L(A, O) = \max(1 - P_{\mathrm{FET}}(A, \mathrm{obs}^{-1}(O), G), L_{\min})^{\beta_R}.\]</p><p>The <em>relevance score</em> quickly approaches <span>$1$</span>, when the representation of the term among all observed genes is significant. <span>$L_{\min} \in [0, 1]$</span> controls that the terms don&#39;t get overpenalized due to low representation. For more practical discussion, see <a href="mosaic.html#set_relevance">&quot;Set relevance&quot;</a> section.</p><p>The <em>enrichment</em> component is defined as</p><p class="math-container">\[E(Y, \mathcal{X}) = \epsilon - \sum_j^{M_X} \alpha^{(j-1)} \left(- \log P_{\mathrm{FET}}(Y, X_{i_j}, O)\right)^{\beta},\]</p><p>where <span>$\epsilon \ge 0$</span> is the penalty for including arbitrary term into a cover; <span>$i_1$</span>, <span>$i_2$</span>, <span>$\ldots$</span>, <span>$i_{M_X}$</span> is the permutation of <span>$1$</span>, <span>$2$</span>, <span>$\ldots$</span>, <span>$M_X$</span> that orders the hits <span>$\mathcal{X}$</span> by the significance of their overlap with <span>$Y$</span> (from most to least significant); <span>$\alpha \in (0, 1]$</span> is the <em>enrichment discount</em>, and <span>$\beta &gt; 0$</span> is the <em>enrichment shape</em>.</p><p>The discount parameter <span>$\alpha$</span> is important for complex data (<span>$M_X \gg 1$</span>). It allows terms that are very significant, but only in a few conditions, be preferred over the terms that are moderately represented in most conditions. The lower is <span>$\alpha$</span>, the more enrichment score favors condition-specific terms.</p><p>The <em>enrichment shape</em> parameter <span>$\beta$</span> affects the size of the selected annotation terms. For small <span>$\beta$</span> the method would prefer several smaller and more specific terms over the single one that combines multiple small terms.</p><h3 id="Redundancy-score"><a class="docs-heading-anchor" href="#Redundancy-score">Redundancy score</a><a id="Redundancy-score-1"></a><a class="docs-heading-anchor-permalink" href="#Redundancy-score" title="Permalink"></a></h3><p class="math-container">\[q_r(C) = \sum_{i=1}^{N_T} \sum_{j=1}^{N_T} \min(c_i, c_j) R(\mathrm{obs}(A_i), \mathrm{obs}(A_j)),\]</p><p>where <span>$R(\mathrm{obs}(A_i), \mathrm{obs}(A_j))$</span> measures the redundancy of observed entities from <span>$A_i$</span> and <span>$A_j$</span> annotation terms as the enrichment of one term in their union:</p><p class="math-container">\[R(B_i, B_j) = -\left( -\log \min \left(
  P_{\mathrm{FET}}(B_i, B_i \cup B_j, N_O (1 + \Delta)),
  P_{\mathrm{FET}}(B_j, B_i \cup B_j, N_O (1 + \Delta)) \right)\right)^\beta,\]</p><p>where <span>$\Delta N_O \ge 0$</span> is added to keep the overlap significant for very large annotation terms that are comparable in size to the set of all observed genes <span>$O$</span>.</p><h3 id="Hits-cover-scores"><a class="docs-heading-anchor" href="#Hits-cover-scores">Hits cover scores</a><a id="Hits-cover-scores-1"></a><a class="docs-heading-anchor-permalink" href="#Hits-cover-scores" title="Permalink"></a></h3><p><span>$q_u$</span> counts how many hit entities were <em>not covered</em> by the selected terms:</p><p class="math-container">\[q_u(C, \mathcal{X}) = \sum_{o \in \cup_i X_i} \left(1 - \max_{j \in С(o)} c_j\right),\]</p><p>where <span>$С(o)$</span> is the set of all indices <span>$j$</span>, s.t. <span>$o \in \mathrm{obs}(A_j)$</span>.</p><p>Similarly, <span>$q_c$</span> counts how many non-hit observations in <em>each</em> experiment are <em>covered</em> by the selected terms:</p><p class="math-container">\[q_c(C, \mathcal{X}) = \sum_{i=1}^{M_X} \sum_{o \in O\setminus X_i} \max_{j \in С(o)} c_j.\]</p><h3 id="Optimal-covers"><a class="docs-heading-anchor" href="#Optimal-covers">Optimal covers</a><a id="Optimal-covers-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-covers" title="Permalink"></a></h3><p>With <span>$q = (q_e, q_u, q_c, q_r)$</span> cover quality defined, one can consider the <em>multi-objective optimization problem</em> of finding the <a href="https://en.wikipedia.org/wiki/Pareto_efficiency">Pareto-optimal</a> family of covers <span>$\mathcal{C}_{*} = \{ C_{*, 1}, C_{*, 2}, \ldots \}$</span>:</p><p class="math-container">\[\forall C \not\in \mathcal{C}_{*} \;\exists C_{*} \in \mathcal{C}_{*}: 
q_e(C_*) \leq q_e(C), q_r(C_*) \leq q_r(C), q_u(C_*) \leq q_u(C_*), q_c(C_*) \leq q_c(C),\]</p><p>and at least for one of the <span>$q$</span> components the inequality is strict.</p><p>The resulting Pareto front <span>$\mathcal{C}_{*}$</span> will contain: the covers with minimally redundant but less enriched terms, very redundant covers of more enriched terms, as well as intermediate solutions between these extremes. It&#39;s possible to weight the importance of individual quality components (<span>$w_e = 1$</span>, <span>$w_r &gt; 0$</span>, <span>$w_u \ge 0$</span>, <span>$w_c \ge 0$</span>) to identify the unique optimal cover <span>$C_{*, \Sigma} \in \mathcal{C}_{*}$</span> that minimizes the components weighted sum:</p><p class="math-container">\[q_{\Sigma}(C) = q_e(C) + w_r q_r(C) + w_u q_u(C) + w_c q_c(C) \to \min, \quad C \in \mathcal{C}_{*}.\]</p><h3 id="cover_score_convolution"><a class="docs-heading-anchor" href="#cover_score_convolution">Components convolution</a><a id="cover_score_convolution-1"></a><a class="docs-heading-anchor-permalink" href="#cover_score_convolution" title="Permalink"></a></h3><p>The number of points on the approximated 4-objective Pareto front is <span>$O(\frac{1}{\delta^{(4-1)}})$</span>, where <span>$\delta &gt; 0$</span> is the grid step in the multi-objective space. The maintenance of such front creates significant overhead during optimization. However, as the components <span>$q_u$</span> and <span>$q_c$</span> correlate with the enrichment component <span>$q_e$</span>, they could be convoluted with the <span>$q_e$</span>:</p><p class="math-container">\[\tilde{q}_e = q_e + w_u q_u + w_c q_c,\]</p><p>or omitted altogether by setting <span>$w_u = w_c = 0$</span>. The optimization of the simplified 2-objective <span>$(\tilde{q}_e, q_r)$</span> problem would require much less resources. The corresponding Pareto front would essentially show the trade-offs between the annotation terms enrichment <span>$\tilde{q}_e$</span> and their redundancy <span>$q_r$</span>. One can define the <em>redunancy index</em> <span>$k_r$</span> as</p><p class="math-container">\[k_r(C) = \frac{q_r(C)}{-\tilde{q}_e(C)}.\]</p><p>High <span>$k_r(C)$</span> means the terms in the cover <span>$C$</span> are redundant. In practice, covers with <span>$k_r(C) \gg 1$</span>, although marginally improving <span>$q_e$</span>, do not reveal any new patterns in the data. To improve the optimization efficiency, it&#39;s possible to use the modified cover score <span>$\tilde{q}$</span>, so that the covers with high <span>$k_r$</span> become dominated by less redundant covers, and thus keep only the relevant solutions on the Pareto front:</p><p class="math-container">\[\tilde{q} = \left(\tilde{q}_e + w_r t q_r, (1 - t) q_r \right),\;\text{where}\\
t = \frac{1}{k_r} \left(w_r + \exp\left(s^{-1} - s\right)\right)^{-1}, \quad
s = \alpha_k \max(k_r - k_{\max}, 0),\]</p><p><span>$k_{\max}$</span> is the maximal accepted redundancy index (by default the method uses <span>$k_{\max} = 1$</span>), and <span>$\alpha_k &gt; 0$</span> defines the transformation strength. With this definition, when <span>$k_r(C) \leq k_{\max}$</span>, then <span>$s = 0$</span>, <span>$t = 0$</span>, and both score components are unchanged: <span>$\tilde{q} = (\tilde{q}_e, q_r)$</span>. When <span>$k_r(C) \gg k_{\max}$</span>, i.e. when the redundancy of the cover is very high, <span>$t \approx \frac{1}{k_r w_r} = \frac{-\tilde{q}_e}{w_r q_r}$</span>, and <span>$\tilde{q} \approx (0, q_r + \frac{\tilde{q}_e}{w_r})$</span>. The latter solution is dominated by any less redundant cover.  Also note that, for any <span>$C$</span>, <span>$\tilde{q}_1 + w_r \tilde{q}_2 = q_{\Sigma}$</span>, so this  transformation preserves the optimal cover <span>$C_{*,\Sigma}$</span> that minimizes <span>$q_{\Sigma}(C)$</span>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Introduction</a><a class="docs-footer-nextpage" href="mosaic.html">Sets collection »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 2 December 2023 22:27">Saturday 2 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
